\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{listings}
\usepackage{tikz}
\usepackage{multirow}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[T2A]{fontenc}

\begin{titlepage}
\centering
{МИНИСТЕРСТВО НАУКИ И ВЫСШЕГО ОБРАЗОВАНИЯ\\
РОССИЙСКОЙ ФЕДЕРАЦИИ}

\vspace{1em}

Федеральное государственное автономное образовательное учреждение высшего образования\\
\textbf{«Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского»}\\
\textbf{(ННГУ)}

\vspace{2em}

\textbf{Институт информационных технологий, математики и механики}

\vspace{1em}

\textbf{Кафедра высокопроизводительных вычислений и системного программирования}

\vspace{2em}

Направление подготовки: "Прикладная математика и информатика"\\
Профиль подготовки: "общий профиль" \\

\vspace{4em}


\textbf{\Large ОТЧЕТ}\\
по третьей лабораторной работе\\
\text{на тему:}\\
\vspace{1em}
\vspace{1em}
\textbf{«Алгоритм Беллмана-Форда и его параллельная реализация»}


\vspace{5em}

\begin{flushright}
\textbf{Выполнил}:\\[5pt]
студент группы \line{3822Б1ПМоп3} \\[1em]
\line{Вавилов Виталий Вадимович}
\end{flushright}

\vspace{2em}

\begin{flushright}

\noindent\textbf{Проверил:} \\[5pt]
к. т. н., доцент кафедры ВВСП \\[5pt]
\line{Сысоев Александр Владимирович}
\end{flushright}

\vfill
\textbf{Нижний Новгород}\\
2024
\end{titlepage}

\begin{document}

\section{Введение}

Алгоритм Беллмана-Форда играет важную роль в теории графов и находит широкое применение в задачах,
связанных с оптимизацией и анализом сетевых структур. Его актуальность обусловлена универсальностью и надежностью при работе с графами, содержащими рёбра с отрицательными весами, что делает его незаменимым инструментом в тех случаях, где другие алгоритмы, например, Дейкстры, оказываются неприменимы.Это свойство критически важно для приложений, связанных с финансовыми моделями, где отрицательные циклы могут указывать на возможность арбитража, или для анализа систем управления, где такие циклы могут указывать на логические ошибки в моделировании процессов:

\begin{enumerate}
    \item \textit{Сетевые маршрутизаторы и протоколы маршрутизации.}
       Алгоритм активно используется в сетевых протоколах, таких как RIP (Routing Information Protocol), для нахождения оптимальных маршрутов в сетях передачи данных.
    \item \textit{Финансовые модели.}
       В банковской и инвестиционной сфере алгоритм применяется для анализа графов валютных курсов или финансовых инструментов, где рёбра графа представляют обменные курсы, а отрицательные циклы сигнализируют о возможности арбитража.
    \item\textit{Транспортные системы.}
       В логистике и транспортной индустрии алгоритм применяется для оптимизации маршрутов в сетях с переменными или отрицательными затратами, например, при учёте скидок, возвратов или штрафов.
\end{enumerate}

В данной работе особое внимание будет уделено как последовательной реализации алгоритма, так и его MPI версии. Параллельная реализация позволяет существенно ускорить вычисления на больших графах, распределяя нагрузку между несколькими узлами вычислительной системы. Это особенно важно для современных задач анализа больших данных, где графы могут содержать миллионы вершин и рёбер.


\section{Постановка задачи и цель работы}

\subsection{Математическая постановка задачи}

Рассматривается задача нахождения кратчайших путей из одной исходной вершины \( s \) во взвешенном ориентированном графе \( G = (V, E) \), где:
\begin{itemize}
    \item \( V \) — множество вершин графа (\( |V| = n \)),
    \item \( E \) — множество рёбер графа (\( |E| = m \)),
    \item Каждое ребро \( e = (u, v) \in E \) имеет вес \( w(u, v) \), который может быть как положительным, так и отрицательным, но в графе отсутствуют циклы с отрицательными весами.
\end{itemize}

Требуется определить минимальные стоимости путей из исходной вершины \( s \) до всех остальных вершин графа. Если вершина недостижима из \( s \), её стоимость пути считается равной \( \infty \).

\begin{itemize}
    \item Для каждой вершины \( v \in V \) вводится значение \( d(v) \), которое обозначает минимальную стоимость пути из вершины \( s \) до вершины \( v \).
    \item На начальном этапе:
    \[
    d(s) = 0, \quad d(v) = \infty \quad \forall v \in V \setminus \{s\}.
    \]
    \item Для каждого ребра \( (u, v) \in E \) и веса \( w(u, v) \) выполняется проверка:
    \[
    d(v) = \min(d(v), d(u) + w(u, v)).
    \]
\end{itemize}

\subsection{Цель работы и задачи работы}

Целью работы является реализация параллельного алгоритма нахождения кратчайших путей на основе алгоритма Беллмана-Форда с использованием MPI.
Достижение данной цели требует решения следующих задач:
\begin{enumerate}
    \item Построить математическую модель задачи нахождения кратчайших путей в графе.
    \item Реализовать алгоритм Беллмана-Форда в формате CRS (Compressed Row Storage).
    \item Разработать параллельную версию алгоритма с использованием MPI, включающую:
    \begin{itemize}
        \item равномерное распределение вершин графа между процессами;
        \item обмен данными между процессами;
        \item проверку наличия отрицательных циклов.
    \end{itemize}
    \item Провести экспериментальное исследование производительности разработанного алгоритма на графах различной размерности.
    \item Сравнить эффективность параллельной версии с последовательной реализацией.
\end{enumerate}

\section{Описание последовательной версии алгоритма}

Алгоритм Беллмана-Форда работает следующим образом:

\begin{itemize}
    \item \textbf{Инициализация:} Устанавливаем расстояния до всех вершин как бесконечность, за исключением исходной вершины, расстояние до которой равно нулю:
    \[
    dist[v] = \infty \quad \forall v \neq source, \quad dist[source] = 0
    \]
    
    \item \textbf{Итерации:} Алгоритм повторяет следующие шаги \(V-1\) раз:
    \[
    dist[u] + w(u, v) < dist[v] \quad \Rightarrow \quad dist[v] = dist[u] + w(u, v)
    \]
    где \(w(u, v)\) — это вес рёбра от вершины \(u\) к вершине \(v\).
    
    \item \textbf{Проверка на отрицательные циклы:} После выполнения \(V-1\) итераций, если ещё возможно обновить расстояние, значит граф содержит отрицательный цикл.
\end{itemize}

\subsection{Выбор формата хранения графа}

Граф можно хранить в различных форматах, включая список рёбер и формат CRS (Compressed Row Storage). В ходе работы были реализованы обе версии хранения, однако для MPI-реализации предпочтение было отдано формату CRS, так как он обеспечивает более высокую эффективность за счёт компактного представления данных и удобства при итерации по смежным вершинам. В дальнейшем рассмотрение алгоритма и его реализации будет производиться именно на основе CRS-формата.


\subsection{Формат хранения графа: список рёбер}

Граф может быть представлен в формате списка рёбер, где каждая строка содержит информацию о рёбре графа. Формально, граф \( G = (V, E) \) хранится как множество рёбер \( E \), где каждое ребро представлено кортежем \((u, v, w)\), где:
\begin{itemize}
    \item \( u \) — вершина, из которой исходит ребро,
    \item \( v \) — вершина, в которую входит ребро,
    \item \( w \) — вес ребра.
\end{itemize}

\subsubsection{Пример}

Для графа:

\[
\text{Граф: } (0,1,2), (0,2,4), (1,2,3), (1,3,5), (2,3,1), (3,4,7)
\]

\textbf{Описание рёбер:}
\[
\begin{array}{|c|c|c|}
\hline
u & v & w \\
\hline
0 & 1 & 2 \\
0 & 2 & 4 \\
1 & 2 & 3 \\
1 & 3 & 5 \\
2 & 3 & 1 \\
3 & 4 & 7 \\
\hline
\end{array}
\]

\subsubsection{Особенности формата}

\begin{itemize}
    \item \textbf{Преимущества:}
    \begin{itemize}
        \item Компактное хранение графа, особенно если граф разреженный (\( |E| \ll |V|^2 \)).
        \item Удобство при итерации по всем рёбрам.
        \item Простота преобразования в другие форматы (например, матрицу смежности или CRS).
    \end{itemize}
    \item \textbf{Недостатки:}
    \begin{itemize}
        \item Отсутствие прямого доступа к соседям конкретной вершины \( v \). Для этого требуется пройти весь список рёбер.
        \item Менее эффективен для плотных графов.
    \end{itemize}
\end{itemize}

\subsection{Формат хранения графа: CRS}

Формат CRS включает три массива:

\begin{itemize}
    \item \textbf{values}: содержит веса всех рёбер в порядке их хранения.
    \item \textbf{columns}: указывает, к каким вершинам ведут рёбра.
    \item \textbf{row\_ptr}: индекс начала списка рёбер для каждой вершины.
\end{itemize}

Рассмотрим следующий граф с 5 вершинами, представленный матрицей смежности:

\[
\begin{bmatrix}
0 & 10 & 5 & 0 & 0 \\
0 & 0 & 2 & 0 & 0 \\
0 & 0 & 0 & 3 & 0 \\
0 & 0 & 0 & 0 & 9 \\
0 & 4 & 0 & 0 & 0 \\
\end{bmatrix}
\]

В этом графе рёбра имеют следующие веса:
\[
(0 \to 1, 10), (0 \to 2, 5), (1 \to 2, 2), (2 \to 3, 3), (3 \to 4, 9), (4 \to 1, 4)
\]

Для данного графа массивы будут выглядеть следующим образом:

\[
\text{values} = [10, 5, 2, 3, 9, 4]
\]
\[
\text{columns} = [1, 2, 2, 3, 4, 1]
\]
\[
\text{row\_ptr} = [0, 2, 3, 4, 5, 6]
\]

\subsubsection{Инициализация расстояний}

Изначально расстояния до всех вершин равны бесконечности (\(\infty\)), кроме начальной вершины \(0\), для которой расстояние равно \(0\):
\[
dist = [0, \infty, \infty, \infty, \infty]
\]

\subsubsection{Шаги итераций}

Выполним \(V-1\) итераций алгоритма, обновляя расстояния на основе рёбер, хранимых в CRS.

\paragraph{Первая итерация:}

Обрабатываем каждое ребро:
\[
\begin{aligned}
&0 \to 1, 10: dist[1] = \min(\infty, 0 + 10) = 10, \\
&0 \to 2, 5: dist[2] = \min(\infty, 0 + 5) = 5, \\
&1 \to 2, 2: dist[2] = \min(5, 10 + 2) = 5 \text{ (не меняется)}, \\
&2 \to 3, 3: dist[3] = \min(\infty, 5 + 3) = 8, \\
&3 \to 4, 9: dist[4] = \min(\infty, 8 + 9) = 17, \\
&4 \to 1, 4: dist[1] = \min(10, 17 + 4) = 10 \text{ (не меняется)}.
\end{aligned}
\]

Результат после первой итерации:
\[
dist = [0, 10, 5, 8, 17]
\]

\paragraph{Вторая итерация:}

Обрабатываем каждое ребро:
\[
\begin{aligned}
&0 \to 1, 10: dist[1] = \min(10, 0 + 10) = 10 \text{ (не меняется)}, \\
&0 \to 2, 5: dist[2] = \min(5, 0 + 5) = 5 \text{ (не меняется)}, \\
&1 \to 2, 2: dist[2] = \min(5, 10 + 2) = 5 \text{ (не меняется)}, \\
&2 \to 3, 3: dist[3] = \min(8, 5 + 3) = 8 \text{ (не меняется)}, \\
&3 \to 4, 9: dist[4] = \min(17, 8 + 9) = 17 \text{ (не меняется)}, \\
&4 \to 1, 4: dist[1] = \min(10, 17 + 4) = 10 \text{ (не меняется)}.
\end{aligned}
\]

Результат после второй итерации:
\[
dist = [0, 10, 5, 8, 17]
\]

\paragraph{Третья и четвёртая итерации:}

На следующих итерациях расстояния больше не меняются, так как все рёбра уже удовлетворяют условию минимальности.

\subsubsection{Результат}

После \(V-1 = 4\) итераций алгоритм завершает работу, и расстояния до всех вершин определены:
\[
dist = [0, 10, 5, 8, 17]
\]

\subsubsection{Проверка на отрицательные циклы}

Выполним ещё одну проверку, проходя по всем рёбрам. Если найдётся ребро, которое уменьшает расстояние, значит, существует отрицательный цикл. Для данного графа таких рёбер нет, отрицательных циклов нет.


\section{Описание параллельной версии алгоритма}

Алгоритм Беллмана-Форда можно эффективно распараллелить. В параллельной версии граф разбивается между несколькими процессами, что позволяет ускорить вычисления. Каждый процесс обрабатывает свою часть графа, а после каждой итерации происходит синхронизация данных между процессами.

\subsection{Шаги реализации}

1. \textbf{Рассылка данных о графе:}

   Используется функция \texttt{boost::mpi::broadcast}, чтобы передать данные о графе всем процессам. Рассылаются следующие параметры:
   \begin{itemize}
       \item \texttt{vertices\_} — общее количество вершин в графе;
       \item \texttt{row\_offsets\_} — массив, где для каждой вершины указывается диапазон индексов рёбер в массиве \texttt{col\_indices\_};
       \item \texttt{col\_indices\_} — массив целевых вершин для всех рёбер графа;
       \item \texttt{weights\_} — массив весов рёбер.
   \end{itemize}
   Каждая функция вызова имеет следующий формат:
   \[
   \text{boost::mpi::broadcast(world, data, 0)}
   \]
   Здесь:
   \begin{itemize}
       \item \texttt{world} — коммуникатор MPI, представляющий все процессы;
       \item \texttt{data} — передаваемые данные;
       \item \texttt{0} — ранг процесса-источника, который передаёт данные.
   \end{itemize}
   В результате все процессы получают копии массивов \texttt{row\_offsets\_}, \texttt{col\_indices\_} и \texttt{weights\_}.

2. \textbf{Инициализация массива расстояний:}

   Если массив \texttt{distances\_} пуст (т.е. вызывается первый запуск), он инициализируется значениями \texttt{INT\_MAX}.

   После этого массив передаётся всем процессам:
   \[
   \text{boost::mpi::broadcast(world, distances\_, 0)}
   \]
   
2. \textbf{Определение локальных индексов:}

   Для каждого процесса определяется диапазон вершин, над которыми он будет работать:
   \[
   \text{local\_start} = \text{world.rank()} \times \left(\frac{\text{vertices\_}}{\text{world.size()}}\right) + \min(\text{world.rank()}, \text{vertices\_} \% \text{world.size()})
   \]
   \[
   \text{local\_end} = \text{local\_start} + \left(\frac{\text{vertices\_}}{\text{world.size()}}\right) + (\text{world.rank()} < \text{vertices\_} \% \text{world.size()} ? 1 : 0)
   \]
   Здесь \(\text{vertices\_}\) — общее количество вершин в графе, \(\text{world.size()}\) — количество процессов, а \(\text{world.rank()}\) — идентификатор текущего процесса.
   Разделение осуществляется с учётом равномерного распределения вершин между процессами. Если количество вершин не делится на число процессов, то некоторые процессы получают на одну вершину больше.

3. \textbf{Основной цикл алгоритма:}

   Алгоритм выполняет \(V-1\) итераций, где \(V\) — количество вершин в графе. На каждой итерации происходит обновление локальных расстояний:
   \[
   \text{local\_distances} = \text{distances\_}
   \]
   Для каждой вершины в локальном диапазоне (\(u \in [\text{local\_start}, \text{local\_end})\)) проверяется, можно ли обновить расстояние до её соседей:
   \[
   \text{if (distances\_[u] != INT\_MAX && distances\_[u] + weight < local\_distances[v])}
   \]
   Если условие выполняется, то расстояние обновляется:
   \[
   \text{local\_distances[v] = distances\_[u] + weight}
   \]
   Флаг \(\text{local\_changed}\) указывает, были ли изменения в локальных расстояниях.

4. \textbf{Синхронизация изменений между процессами:}
   После выполнения локальных вычислений происходит синхронизация изменений среди всех процессов с помощью \texttt{boost::mpi::all\_reduce}:
   \[
   \text{boost::mpi::all\_reduce(world, local\_distances.data(), vertices\_, distances\_.data(), [](int a, int b) { if (a == INT\_MAX) return b; if (b == INT\_MAX) return a; return std::min(a, b); })}
   \]
   Эта операция собирает минимальные значения для каждой вершины среди всех процессов.
   
5. \textbf{Проверка на прекращение вычислений:}

   Если на данной итерации не произошло изменений в расстояниях, то алгоритм завершает выполнение:
   \[
   \text{bool global\_changed = boost::mpi::all\_reduce(world, local\_changed, std::logical\_or<>())}
   \]
   Если \(\text{global\_changed}\) равно \texttt{false}, то алгоритм завершает работу досрочно.

6. \textbf{Проверка на отрицательные циклы:}

   После выполнения всех итераций проверяется наличие отрицательных циклов в графе. Для каждой вершины проверяется условие:
   \[
   \text{if (distances\_[u] != INT\_MAX && distances\_[u] + weight < distances\_[v])}
   \]
   Если такое условие выполняется, то обнаружен отрицательный цикл.

   После этого производится глобальная синхронизация с помощью \texttt{boost::mpi::all\_reduce}:
   \[
   \text{has\_negative\_cycle = boost::mpi::all\_reduce(world, has\_negative\_cycle, std::logical\_or<>())}
   \]

   Если отрицательный цикл не обнаружен, функция возвращает \texttt{true}.
\subsection{Выводы}

MPI-реализация алгоритма Беллмана-Форда позволяет эффективно вычислять кратчайшие пути в больших графах, распределяя вычисления по нескольким процессам. Алгоритм использует операции рассылки и синхронизации данных с помощью библиотеки \texttt{boost::mpi}, обеспечивая параллельную обработку и сокращение времени вычислений на больших графах.

\section{Анализ производительности}

Замеры производительности проводились на шестиядерном процессоре Intel Core i5-9400F, с максимальным числом потоков, равным шести. 

\subsection{Функциональные тесты (Func Tests)}

Для функциональных тестов использовались случайно сгенерированные матрицы графов. Полученные результаты демонстрируют значительное преимущество MPI-реализации по времени выполнения. Среднее время работы составило:
\begin{itemize}
    \item для последовательной реализации: \(t = 55 \, \text{ms}\);
    \item для MPI-реализации: \(t = 1 \, \text{ms}\).
\end{itemize}
Таким образом, ускорение достигло порядка одного порядка величины.

\subsection{Тесты производительности (Perf Tests)}

Для тестов производительности использовался линейный граф. Такой выбор обусловлен удобством проверки корректности работы алгоритма и сравнения с ожидаемыми результатами. В этом случае:

\begin{itemize}
    \item Выигрыш по времени выполнения MPI-реализации относительно последовательной версии был заметным. 
    Для тестирования был взят граф с 5000 вершинами:
    \begin{itemize}
        \item Последовательная версия: \texttt{task\_run: 0.2064924000} (\texttt{vavilov\_v\_bellman\_ford\_seq.test\_task\_run}, 248~ms).
        \item MPI-версия: \texttt{task\_run: 0.0011056997} (\texttt{vavilov\_v\_bellman\_ford\_mpi.test\_task\_run}, 218~ms).
    \end{itemize}
    \item Увеличение числа потоков приводило к незначительному улучшению производительности. Вероятной причиной такого поведения является небольшая степень параллелизма в задаче, связанная с линейной структурой графа.
\end{itemize}

\subsection{Тесты с рандомными матрицами}

Локально были проведены тесты с рандомными разреженными графами:
\begin{itemize}
    \item MPI-реализация превосходила последовательную версию в несколько раз, причем увеличение числа потоков в данном случае гораздо сильнее повлияло на конечный результат. Тесты проводились с 5000 вершинами и 2000 ребрами:
    \begin{itemize}
        \item MPI-версия 4 потока: \texttt{task\_run: 0.09643567000} (\texttt{vavilov\_v\_bellman\_ford\_seq.test\_task\_run}, 924~ms).
        \item MPI-версия 2 потока: \texttt{task\_run: 0.08004732500} (\texttt{vavilov\_v\_bellman\_ford\_mpi.test\_task\_run}, 1053~ms).
    \end{itemize}
    
\end{itemize}

\subsection{Тесты с графом в формате списка рёбер}

Дополнительно проводились тесты с графом, хранящимся в формате списка рёбер. Результаты показали, что этот формат уступает по производительности версии с хранением в формате CRS. Это связано с более эффективным использованием памяти и удобством обработки в CRS-структуре.

\subsection{Выводы}

Результаты тестов демонстрируют эффективность MPI-реализации для задач на графах с произвольной структурой. Однако при работе с графами специфических типов (например, линейными графами) прирост производительности может быть незначительным. Формат хранения графа также играет важную роль: CRS-формат показал себя как наиболее эффективный в сравнении с форматом списка рёбер.

\section{Список литературы}
\begin{enumerate}
\item Кормен Т., Лейзерсон Ч., Ривест Р., Штайн К. \textit{Алгоритмы: построение и анализ}. \newline М.: Вильямс, 2020.
\item MPI: A Message-Passing Interface Standard. \url{https://www.mpi-forum.org/}
\end{enumerate}

\section{Заключение}
Алгоритм Беллмана-Форда является эффективным методом поиска кратчайших путей в графах с возможными отрицательными весами рёбер. Параллельная версия алгоритма с использованием MPI позволяет значительно ускорить вычисления, особенно для больших графов. Использование синхронизации между процессами гарантирует корректность выполнения алгоритма. Будущие исследования могут быть направлены на оптимизацию коммуникаций между процессорами.

\section{Фрагменты кода программы}

\begin{lstlisting}[language=C++, caption={Последовательная реализация алгоритма Беллмана–Форда}]
bool vavilov_v_bellman_ford_seq::TestTaskSequential::run() {
  internal_order_test();

  for (int i = 0; i < vertices_ - 1; ++i) {
    for (int u = 0; u < vertices_; ++u) {
      for (int j = row_offsets_[u]; j < row_offsets_[u + 1]; ++j) {
        int v = col_indices_[j];
        int weight = weights_[j];
        if (distances_[u] != INT_MAX && distances_[u] + weight < distances_[v]) {
          distances_[v] = distances_[u] + weight;
        }
      }
    }
  }

  for (int u = 0; u < vertices_; ++u) {
    for (int j = row_offsets_[u]; j < row_offsets_[u + 1]; ++j) {
      int v = col_indices_[j];
      int weight = weights_[j];
      if (distances_[u] != INT_MAX && distances_[u] + weight < distances_[v]) {
        return false;
      }
    }
  }

  return true;
}

\end{lstlisting}

\begin{lstlisting}[language=C++, caption={Параллельная MPI-реализация алгоритма Беллмана–Форда}]
bool vavilov_v_bellman_ford_mpi::TestMPITaskParallel::run() {
  internal_order_test();

  boost::mpi::broadcast(world, vertices_, 0);
  boost::mpi::broadcast(world, row_offsets_, 0);
  boost::mpi::broadcast(world, col_indices_, 0);
  boost::mpi::broadcast(world, weights_, 0);

  if (distances_.empty()) {
    distances_.resize(vertices_, INT_MAX);
  }
  boost::mpi::broadcast(world, distances_, 0);

  int local_start = world.rank() * (vertices_ / world.size()) + std::min(world.rank(), vertices_ % world.size());
  int local_end = local_start + (vertices_ / world.size()) + (world.rank() < vertices_ % world.size() ? 1 : 0);

  for (int i = 0; i < vertices_ - 1; ++i) {
    std::vector<int> local_distances = distances_;
    bool local_changed = false;

    for (int u = local_start; u < local_end; ++u) {
      for (int j = row_offsets_[u]; j < row_offsets_[u + 1]; ++j) {
        int v = col_indices_[j];
        int weight = weights_[j];
        if (distances_[u] != INT_MAX && distances_[u] + weight < local_distances[v]) {
          local_distances[v] = distances_[u] + weight;
          local_changed = true;
        }
      }
    }

    boost::mpi::all_reduce(world, local_distances.data(), vertices_, distances_.data(), [](int a, int b) {
      if (a == INT_MAX) return b;
      if (b == INT_MAX) return a;
      return std::min(a, b);
    });

    bool global_changed = boost::mpi::all_reduce(world, local_changed, std::logical_or<>());
    if (!global_changed) break;
  }

  bool has_negative_cycle = false;
  for (int u = local_start; u < local_end; ++u) {
    for (int j = row_offsets_[u]; j < row_offsets_[u + 1]; ++j) {
      int v = col_indices_[j];
      int weight = weights_[j];
      if (distances_[u] != INT_MAX && distances_[u] + weight < distances_[v]) {
        has_negative_cycle = true;
        break;
      }
    }
  }

  has_negative_cycle = boost::mpi::all_reduce(world, has_negative_cycle, std::logical_or<>());
  return !has_negative_cycle;
}
\end{lstlisting}

\end{document}


