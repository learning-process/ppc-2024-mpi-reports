\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage[T1]{fontenc}
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{titlesec}
\usepackage{hyperref}
\usepackage{tocloft}
\usepackage{xcolor} 
\usepackage{listings}
\usepackage{float}

\geometry{a4paper, left=25mm, right=15mm, top=20mm, bottom=20mm}

\lstset{
  language=C++,
  basicstyle=\ttfamily\small,
  keywordstyle=\bfseries\color{blue},
  commentstyle=\itshape\color{green!50!black},
  stringstyle=\color{red!60!black},
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=8pt,
  backgroundcolor=\color{gray!10},
  showspaces=false,
  showstringspaces=false,
  breaklines=true,
  frame=single,
  tabsize=2,
  captionpos=b
}

\begin{document}
\begin{titlepage}
    \centering
    \large
    Министерство науки и высшего образования Российской Федерации\\[0.5cm]
    Федеральное государственное автономное образовательное учреждение высшего образования\\[0.5cm]
    \textbf{«Национальный исследовательский Нижегородский государственный университет им. Н.И. Лобачевского»}\\
    (ННГУ)\\[1cm]
    Институт информационных технологий, математики и механики\\[0.5cm]
    Направление подготовки: \textbf{«Программная инженерия»}\\[1cm]

    \vfill % Вертикальное заполнение для центрирования текста
    {\LARGE \textbf{ОТЧЕТ}}\\[0.5cm]
    {\Large по задаче}\\[0.5cm]
    {\LARGE \textbf{«Построение выпуклой оболочки для компонент бинарного изображения»}}\\[0.5cm]
    {\Large \textbf{Вариант №32}}\\[2.5cm]

    \hfill\parbox{0.5\textwidth}{
        \textbf{Выполнила:} \\
        студентка группы 3822Б1ПР1 \\
        \textbf{Сидорина Полина}
    }\\[0.5cm]

    \hfill\parbox{0.5\textwidth}{
        \textbf{Преподаватели:} \\
        Нестеров А.Ю.
        Оболенский А.А.

    }\\[2cm]

    Нижний Новгород\\
    2024
\end{titlepage}

\tableofcontents
\newpage

\section*{Введение}
\addcontentsline{toc}{section}{Введение}

Данный отчёт содержит в себе полное описание реализации задачи построения выпуклой оболочки для компонент бинарного изображения.

Построение выпуклой оболочки — одна из ключевых задач в области обработки изображений и вычислительной геометрии. Она применяется в различных областях, таких как компьютерное зрение, робототехника и автоматизация производства. Выпуклая оболочка позволяет выделить наиболее важные точки изображения, что упрощает дальнейшую обработку и анализ данных.

Для решения задачи построения выпуклой оболочки для компонент бинарного изображения можно использовать алгоритм Джарвиса, также известный как алгоритм Грэхема — Джарвиса. Этот метод обеспечивает высокую эффективность за счёт применения алгоритмов сортировки и поиска.

Алгоритм Джарвиса позволяет построить выпуклую оболочку за время O(nh), где n — количество точек на изображении, а h — размерность выпуклой оболочки. Это делает его особенно полезным для работы с большими наборами данных.

Преимущество алгоритма Джарвиса заключается в его простоте и эффективности, что делает его популярным выбором для задач построения выпуклой оболочки. Он широко применяется в области обработки изображений и вычислительной геометрии.

Использование параллельных вычислений с применением MPI (Message Passing Interface) позволяет ускорить процесс построения выпуклой оболочки с помощью алгоритма Джарвиса на распределённых системах. Это обеспечивает более быстрое выполнение задачи и повышает эффективность работы с данными.

\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}
Цель работы — разработать и исследовать алгоритм построения выпуклой оболочки методом Джарвиса, уделив особое внимание его последовательной и параллельной реализации.
Для достижения этой цели необходимо выполнить следующие задачи:
\begin{itemize}
    \item Реализовать последовательный метод Джарвиса.
    \item Разработать параллельную версию алгоритма с применением библиотеки MPI, чтобы распределить вычисления между процессами и повысить производительность.
    \item Сравнить скорость работы последовательной и параллельной версий.
    \item Провести эксперименты, меняя количество процессов и варьируя входные параметры точности, чтобы оценить результативность параллельного подхода.
    \item Провести функциональное тестирование последовательной и параллельной версии алгоритма, чтобы подтвердить корректность их работы и совпадение результатов.
    \item Подготовить отчёт, отражающий этапы разработки, результаты экспериментов и выводы по эффективности алгоритма.
\end{itemize}

\section*{Описание алгоритма}
\addcontentsline{toc}{section}{Описание алгоритма}
\subsection*{Алгоритм Джарвиса (или алгоритм Грэхема — Джарвиса)} для построения выпуклой оболочки набора точек на плоскости работает следующим образом:
\begin{itemize}
\item  \textbf{Выбор начальной точки.} Выбирается самая нижняя точка из множества точек, которые будут использоваться для построения оболочки. Если есть несколько точек с одинаковой минимальной координатой y, то выбирается точка с наименьшей координатой x. Эта точка становится первой вершиной выпуклой оболочки.
\item  \textbf{Добавление соседних точек.} Затем алгоритм проходит по всем остальным точкам и проверяет, находятся ли они слева от прямой, проведённой через текущую точку и предыдущую вершину оболочки. Если точка находится слева от этой прямой, она добавляется к оболочке. Это продолжается до тех пор, пока все точки не будут обработаны.
\item \textbf{Удаление внутренних точек.} После добавления всех точек алгоритм удаляет все внутренние точки, которые не являются вершинами оболочки. Это делается для того, чтобы оболочка была минимальной и охватывала только внешние границы множества точек.
\item  \textbf{Повторение.} Процесс повторяется до тех пор, пока не будут обработаны все точки. В результате получается выпуклая оболочка, которая охватывает все внешние границы множества точек. 
\item  \textbf{Завершение работы алгоритма.} Когда все точки обработаны, алгоритм завершает свою работу.
\end{itemize}
\subsection*{Применение алгоритма Джарвиса для бинарных изображений:}

Бинарное изображение представляет собой матрицу, в которой каждый пиксель имеет значение 0 или 1. В контексте обработки изображений, 1 обычно обозначает наличие объекта или интересующей области, а 0 — отсутствие.

Для применения алгоритма Джарвиса к бинарному изображению необходимо сначала преобразовать его в набор точек. Каждая точка будет представлять собой координаты пикселя на изображении. Затем можно применить алгоритм Джарвиса для построения выпуклой оболочки этого набора точек.

Результатом работы алгоритма будет выпуклая оболочка, охватывающая все внешние границы объектов на бинарном изображении. Эта оболочка может быть использована для различных целей, таких как сегментация изображения, определение формы объектов и т. д.

Чтобы применить алгоритм Джарвиса, нужно разбить бинарное изображение на компоненты. Для этого следует выполнить следующие шаги:
\begin{itemize}
\item Определить связанные области пикселей на основе их значений (1 или 0).
\item Для каждой связанной области выбрать начальную точку, которая будет использоваться для построения выпуклой оболочки с помощью алгоритма Джарвиса.
\item Применить алгоритм Джарвиса к каждой компоненте бинарного изображения отдельно.
\end{itemize}
Таким образом, после разбиения бинарного изображения на компоненты и применения к ним алгоритма Джарвиса мы получим набор выпуклых оболочек, каждая из которых соответствует одной компоненте исходного изображения.

\section*{Схема распараллеливания}
\addcontentsline{toc}{section}{Схема распараллеливания}

Для распараллеливания алгоритма построения выпуклой оболочки для компонент бинарного изображения с использованием алгоритма Джарвиса применила следующую схему:
\begin{itemize}
    \item \textbf{Разделение бинарного изображения на части.}
          Бинарное изображение разделяется на несколько меньших частей, которые могут обрабатываться параллельно. Это позволяет ускорить процесс обработки и уменьшить нагрузку на центральный процессор.

    \item \textbf{Применение алгоритма Джарвиса к каждой части отдельно.}
          Для каждой из полученных частей применяется алгоритм Джарвиса для построения выпуклой оболочки. Это может быть выполнено параллельно, так как каждая часть обрабатывается независимо от других.

    \item \textbf{Объединение результатов.}
          После того как все части обработаны, результаты объединяются в одну общую выпуклую оболочку. Это обеспечивает корректность и полноту результата, несмотря на параллельную обработку.
\end{itemize}

\subsection*{Описание реализации с использованием MPI}
Алгоритм реализует построение выпуклого остова бинарной изображения с помощью MPI. Основные этапы соответствуют общей схеме распараллеливания:

\begin{itemize}
    \item \textbf{Распределение работы по процессам:}
          Изначально компоненты изображения распределяются между доступными MPI-процессами, каждый из которых получает свою часть для обработки. Количество компонентов на каждом процессе рассчитывается таким образом, чтобы максимально равномерно распределить нагрузку.

    \item \textbf{Передача данных между процессами:}
          Процесс с рангом 0 отправляет компоненты изображения остальным процессам.
Остальные процессы получают компоненты и хранят их локально.

    \item \textbf{Построение выпуклого остова на каждом процессе:}
          Каждый процесс использует алгоритм Джарвиса \texttt{jarvis} для построения выпуклого остова своих компонентов. Результат - список вершин, составляющих выпуклый остов.
    \item \textbf{Сбор результатов:}
Процесс с рангом 0 собирает результаты всех процессов и объединяет их в единый список вершин.

    \item \textbf{Создание бинарного изображения:}
          Процесс с рангом 0 использует полученный набор вершин для построения выпуклого остова на исходном изображении (\texttt{bin img}).
 \item \textbf{Возврат результата:}
Процесс с рангом 0 возвращает построенное бинарное изображение.
\end{itemize}

\section*{Результаты экспериментов и вывод}
\addcontentsline{toc}{section}{Результаты экспериментов и вывод}
Экспериментальные результаты показали, что параллельная версия работает быстрее последовательной, но не значительно. Возможным вариантом решения этой проблемы является изменение алгоритма вычисления выпуклой оболочки. Как оказалось, алгоритм Джарвиса для целей задачи не совсем оптимален, так как работает не так быстро при распараллеливании. Однако, положительных результатов всё таки получилось добиться.

\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}
В данной работе был разработан и исследован алгоритм построения выпуклой оболочки методом Джарвиса. Реализация включает как последовательный, так и параллельный подход, что позволяет оценить эффективность распараллеливания вычислений с применением библиотеки MPI.
\newpage
\section*{Литература}
\addcontentsline{toc}{section}{Литература}

\begin{enumerate}
    \item \href{https://habr.com/ru/articles/144921/}{Habr. Статья "Построение минимальных выпуклых оболочек"}.
    \item \href{https://dev.to/sandordargo/parameterized-testing-with-gtest-50l9?ysclid=m4za95jfss441200494}{Статья "Parameterized testing with GTest"}.
\end{enumerate}

\appendix
\newpage
\section*{Приложение}
\addcontentsline{toc}{section}{Приложение}

В данном разделе представлены основные фрагменты реализации алгоритма.

\subsection*{Функция bin img}

\begin{lstlisting}[language=C++]
std::vector<int> bin_img(const std::vector<Point>& points, int width, int height) {
  std::vector<int> image(width * height, 0);
  int size = points.size();
  if (size < 2) return image;

  auto [minX, maxX] =
      std::minmax_element(points.begin(), points.end(), [](const Point& a, const Point& b) { return a.x < b.x; });
  auto [minY, maxY] =
      std::minmax_element(points.begin(), points.end(), [](const Point& a, const Point& b) { return a.y < b.y; });

  for (int x = minX->x; x <= maxX->x; x++) {
    if (x >= 0 && x < width) {
      image[minY->y * width + x] = 1;
      image[maxY->y * width + x] = 1;
    }
  }
  for (int y = minY->y; y <= maxY->y; y++) {
    if (y >= 0 && y < height) {
      image[y * width + minX->x] = 1;
      image[y * width + maxX->x] = 1;
    }
  }

  return image;
}
\end{lstlisting}

\subsection*{Функция mark contours}

\begin{lstlisting}[language=C++]
void mark_contours(std::vector<int>& image, int width, int height, int num) {
  static int counter = 1;

  const auto& func = [&](int i, int j) -> void {
    int del = image[i * width + j];
    int a = 0;
    int b = 0;  // a - left/right, b - up/low

    if (del == 0) return;

    if (a == 0 && b == 0) {
      image[i * width + j] = counter++;
    } else if (num == 1) {
      image[i * width + j] = std::max(a, b);
    }

    if (j == 0)
      a = 0;
    else
      a = image[i * width + (j - 1)];

    if (i == 0)
      b = 0;
    else
      b = image[(i - 1) * width + j];
  };

  switch (num) {
    case 1:
      for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) func(i, j);
      }
      break;
    case 2:
      for (int i = height - 1; i >= 0; i--) {
        for (int j = width - 1; j >= 0; j--) func(i, j);
      }
      break;
    default:
      return;
  }
}
\end{lstlisting}
\subsection*{Функция labeling}

\begin{lstlisting}[language=C++]
std::vector<std::vector<Point>> labeling(const std::vector<int>& image, int width, int height) {
  std::vector<int> label_image(width * height);

  std::copy(image.begin(), image.end(), label_image.begin());
  mark_contours(label_image, width, height, 1);
  mark_contours(label_image, width, height, 2);

  std::unordered_map<int, std::list<Point>> components;

  for (int i = 0; i < height; i++) {
    for (int j = 0; j < width; j++) {
      if (image[i * width + j] == 0) continue;

      int component_label = image[i * width + j];

      auto& comp = components[component_label];
      comp.push_back({j, i});
    }
  }
  std::vector<std::vector<Point>> result;
  result.reserve(components.size());
  for (const auto& [label, points] : components) {
    result.emplace_back(points.begin(), points.end());
  }
  return result;
}
\end{lstlisting}

\subsection*{Функция  jarvis}

\begin{lstlisting}[language=C++]
std::vector<Point> jarvis(std::vector<Point> points) {
  if (points.empty()) return {};

  struct ComparePoints {
    bool operator()(const Point& a, const Point& b) { return (a.y < b.y) || (a.y == b.y && a.x < b.x); }
  };

  Point min_point = points[0];
  for (size_t i = 1; i < points.size(); i++) {
    if (points[i].x < min_point.x || (points[i].x == min_point.x && points[i].y < min_point.y)) {
      min_point = points[i];
    }
  }

  struct Comparator {
    const Point& min_point;

    Comparator(const Point& min_point) : min_point(min_point) {}

    bool operator()(const Point& p1, const Point& p2) {
      int mult = mix_mult(min_point, p1, p2);
      if (mult != 0) return mult > 0;
      return distanceSq(min_point, p1) < distanceSq(min_point, p2);
    }
  };

  std::sort(points.begin(), points.end(), Comparator(min_point));

  std::vector<Point> hull = {min_point};
  for (size_t i = 1; i < points.size(); i++) {
    while (hull.size() > 1 && mix_mult(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {
      hull.pop_back();
    }
    hull.push_back(points[i]);
  }

  return hull;
}
\end{lstlisting}

\end{document}
